## 03. hash、bloom

#### 功能

自己实现哈希函数。使用的是一种类似于`Murmur Hash`的算法，维基百科上的解释是：

> Murmur Hash是一种非加密型哈希函数，适用于一般的哈希检索操作。与其他流行的哈希函数相比，对于规律性较强的key，Murmur Hash的随机分布特征表现更好。

`BloomFilter`，布隆过滤器，是一个非常有意思的用于数据查找的数据结构。由一个很长的二进制向量和一些列随机哈希函数组成。优点是时间和空间的利用效率都非常高，但是缺点是有一定的误识别（不存在的值判断存在）和删除困难。对于要求精度高的场景并不合适。其原理非常直接，对于一个值经过多次哈希映射后，获取一系列位置，然后标记到二进制向量中。当检索的时候，重新映射，检查那个位置上的状态是0还是1。

#### 实现

`hash`具体的实现只有一个函数。

```c++
uint32_t Hash(const char* data, size_t n, uint32_t seed) {
    // similar to murmur hash
    const uint32_t m = 0xc6a4a793;
    const uint32_t r = 24;
    const char* limit = data + n;
    uint32_t h = seed ^ (n * m);

    // pick up four bytes at a time
    while (data + 4 <= limit) {
        uint32_t w = DecodeFixed32(data);
        data += 4;
        h += w;
        h *= m;
        h ^= (h >> 16);
    }

    // pick up remaining bytes
    switch (limit - data) {
        case 3:
            h += static_cast<uint8_t>(data[2]) << 16;
            break;
        case 2:
            h += static_cast<uint8_t>(data[1]) << 8;
            break;
        case 1:
            h += static_cast<uint8_t>(data[0]);
            h *= m;
            h ^= (h >> r);
            break;
    }
    return h;
}
```

过滤策略可能不止一种，因此在高层有个抽象基类`FilterPolicy`。

```c++
namespace leveldb {

class Slice;

class FilterPolicy {
public:
    virtual ~FilterPolicy();

    // Return the name of this policy. Note that if the filter encoding
    // changes in an incompatible way, the name returned by this method
    // must be changed. Otherwise, old incompatible filters may be
    // passed to methods of this type.
    virtual const char* Name() const = 0;

    // keys[0,n-1] contains a list of keys (potentially with duplicates)
    // that are ordered according to the user supplied comparator.
    // Append a filter that summarizes  keys[0,n-1] to *dst
    //
    // Warning: do not change the initial contents of *dst. Instead
    // append the newly constructed filter to *dst
    virtual void CreateFilter(const Slice* keys, int n,
                            std::string* dst) const = 0;

    // "filter" contains the data appended by a preceding call to
    // CreateFilter() ont this class. This method must return true if
    // the key was in the list of keys passed to CreateFilter().
    // This method may return true or flase if the key was not on the
    // list, but it should aim to return false with a high probability.
    virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;
    
};

// Return a new filter policy that uses a bloom filter with approximately
// the specified number of bits per key. A good value for bits_per_key
// is 10, which yields a filter with ~ 1% false positive rate.
const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);
     
}   // namespace leveldb
```

比较简单，就是创建过滤器，以及检查key是否存在。

`BloomFilter`就是继承这个抽象基类，并实现虚方法。

```c++
namespace leveldb {

namespace {

static uint32_t BloomHash(const Slice& key) {
    return Hash(key.data(), key.size(), 0xbc9f1d34);
}

class BloomFilterPolicy : public FilterPolicy {
public:
    explicit BloomFilterPolicy(int bits_per_key) : bits_per_key_(bits_per_key) {
        k_ = static_cast<size_t>(bits_per_key_ * 0.69); // 0.69 ~= ln(2)
        if (k_ < 1) {
            k_ = 1;
        }
        if (k_ > 30) {
            k_ = 30;
        }
    }

    const char* Name() const override {
        return "leveldb.BuildinBloomFilter";
    }

    void CreateFilter(const Slice* keys, int n, std::string* dst) const override {
        // compute bloom filter size (in both bits and bytes)
        size_t bits = n * bits_per_key_;

        // for small n, we can see a very high false positive rate. Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) {
            bits = 64;
        }
        
        size_t bytes = (bits + 7) / 8;
        bits = bytes * 8;

        const size_t init_size = dst->size();
        dst->resize(init_size + bytes, 0);
        dst->push_back(static_cast<char>(k_));  // remember probes
        char* array = &(*dst)[init_size];
        for (int i = 0; i < n; ++i) {
            // use double-hashing to generate a sequence of hash values
            uint32_t h = BloomHash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);   // rotate right 17 bits
            for (size_t j = 0; j < k_; ++j) {
                const uint32_t bitpos = h % bits;
                array[bitpos / 8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }
        
    }

    bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const override {
        const size_t len = bloom_filter.size();
        if (len < 2) {
            return false;
        }

        const char* array = bloom_filter.data();
        const size_t bits = (len - 1) * 8;
        
        // use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];
        if (k > 30) {
            // reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        uint32_t h = BloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);
        for (size_t j = 0; j < k; ++j) {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) {
                return false;
            }
            h += delta;
        }
        return true;
    }

private:
    size_t bits_per_key_;
    size_t k_;
};

}   // namespace

const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
    return new BloomFilterPolicy(bits_per_key);
}
```

内部使用了匿名命名空间，这意味着实际的`BloomFilter`并不直接向外界暴露，而是使用一个类似于工厂函数的方法。

创建过滤器和检查是两个核心函数。本质就是先做映射，然后根据映射得到的二进制向量进行查找。具体细节直接看代码。

#### 理解



#### 参考

- https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C
- https://zh.wikipedia.org/zh-hans/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8